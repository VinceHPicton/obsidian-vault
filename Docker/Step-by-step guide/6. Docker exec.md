You should now understand to a reasonable level what a Dockerfile does, how it works, and you know some of the core Docker CLI commands like build and run.

The final trick I think you need to know to say you've got the core basics of Docker is how to run commands against *already running* containers. This is done with `docker exec` and you'll mostly be using it to connect to a container and investigate what's happening inside it.

This can be done with `docker exec -it <container_name_or_id> /bin/sh` 

Ultimately, that command is the main thing you need to understand from this page, you can move on if you want or stay for a worked example.

**Example**

Edit your main.go file to this http server:
```
package main

import (
    "log"
    "net/http"
)

func main() {
    err := http.ListenAndServe(":80", nil)
    if err != nil {
        log.Fatalf("%v", err.Error())
    }
}
```

And now run a build command with a different -t (tag) option:
`docker build -t empty-http .`

Notice you didn't even need to change your Dockerfile to create a completely different image, which now runs a http server. 

Now run the image with `docker run -d empty-http ./my-go-binary`
- We needed -d here to detach from the container so it doesn't steal our terminal, try it without. You could've omitted the -d and opened a different terminal to do the next steps too.

Run `docker container ls` or `docker ps` (they're the same) to see your running container and its container ID. 

And finally now `docker exec -it <YOUR_CONTAINER_ID> /bin/sh` to enter a terminal session with your container.

If you type `exit` now and then `docker ps` again, you'll see your container is still running. That's because this time the /bin/sh session was not the main process, and killing it didn't stop the container.

Using this, you can hop into your containers, take a look at their logs or whatever else, to diagnose issues or whatever else. 
docker exec is an essential debugging tool.