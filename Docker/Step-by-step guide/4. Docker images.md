If you've been following, you have just built your first image named "my-first-image:latest"

Run the command `go build -o my-go-binary main.go` in your terminal, which was the same command from layer 2 of our Dockerfile. You'll see a file called `my-go-binary` was created
Now run `./my-go-binary` in your terminal and you'll see your Go code run locally to output "Hello, World!", just as expected.

Now run the command:
`docker run my-first-image:latest ./my-go-binary`

You'll see that it also outputted "Hello, World!" just the same as your local Go code did, so what exactly just happened?
- `docker run` instructed docker to create a **container** based on your image.
- It then executed the command you gave inside that container (this was the 2nd arg: "./my-go-binary") .
- This command executes your binary file and the process running that became the "main process" - which is the first process - in the container.
- This main process simply prints "Hello world!" and exits (we reached the end of the main() function in the Go program), so you saw "Hello World!" and then got your terminal back.
- Since the container's "main process" exited, the container automatically stopped. Run `docker container ls -a` to see your now stopped container.
	- Some notes:
	- A container **always** stops when it's main process exits, and when starting a container you can only ever kick off 1 initial process (the main process). 
	- That main process can then spawn other processes during the containers' lifetime, but the container will always stop, killing all other processes, if the main process exits.
	- The "main process" is officially referred to as PID 1 in the docker docs.


**So what?**
Well now you could `docker push` your image to the internet, and someone else could `docker pull` it down, and run your code on their computer, without actually needing your code directly.
 (we'll get to docker push and pull later)

Obviously for this code doesn't really do anything, but if your main.go was, say, the main.go file for your application's entire backend, you could use almost the exact same Dockerfile and `docker run` command to package and run your code anywhere with docker installed. 
(If you were wondering, the only change to your Dockerfile would be the COPY layer, we'd have to copy everything in the directory into the container with `COPY . .`)

An important thing to understand is that as you've seen, the image contains everything your application needs to run as a container - including all your code; when you created your image you will literally copy your whole codebase into your image.

