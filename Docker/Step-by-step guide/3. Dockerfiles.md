- Dockerfile is a type of file which is read by docker to build an image.
- It is a series of instructions which gives docker a step-by-step on how to create the image you want. 
- Each instruction creates an image "layer"
- When you build an image, docker creates a temporary "build container" from the base image (see below), the instructions are executed inside that build container.

Example:
```
# Layer 1
FROM golang:alpine

# Layer 2
COPY main.go .

# Layer 3
RUN go build -o my-go-binary main.go
```

**Layer 1: FROM golang:alpine**
This line says that our base image will be "golang:alpine" which is a premade image provided by docker/go/whoever made it, and when you run this command (if your machine hasn't already pulled it) you'll see that docker will pull this image from the internet (just like pulling a git repo)

- All Dockerfiles must start with a FROM statement which defines your "base image"
- You cannot create a dockerfile without a FROM statement (try it), therefore the most basic possible Dockerfile is:
```
FROM scratch
```
"scratch" is a completely empty image (yes it is also an image), provided by docker as the starting point for all images (this will make sense later, but suffice to say: just think that the golang:alpine image itself must have a FROM statement)


**Layer 2: COPY main.go .**
This line tells docker to copy main.go (which would need to be in the root of the [[Build context|build context]] otherwise we'd hit an error) into "." which means into whatever present working directory the build container has.
Note that we are literally copying our code into the build container, and therefore the image we are creating, so after building this image you could delete your code entirely from your repo, and the image will still have it.

**Layer 3: RUN go build -o my-go-binary main.go**
This RUN line tells the build container to run the command given, again in the current working directory of the container. 
If you know the basics of Go you'll know the Go compiler read the contents of main.go and created a binary file using it named "my-go-binary" placing it in the current directory (inside the container)

**Building your first image**
Now you understand roughly what this dockerfile does:
- Copy it yourself into a file named "Dockerfile" 
- Create a file called "main.go" with contents:
```
package main

import (
    "fmt"
)

func main() {
    fmt.Println("Hello, World!")
}
```

- Ensure you've cd'd to the directory where your Dockerfile is, and run the command:
`docker build -t my-first-image:latest .` 

Don't worry about the details of this command right now, just understand that it has read your Dockerfile and created an image called "my-first-image:latest"
Run the command `docker images` to see this image


**Some notes about Dockerfile naming**
- If a project just has one dockerfile, it'll usually be called "Dockerfile" and will be in the root. This is because if you don't specify a dockerfile's filename when you try to run docker build, docker will look for a file called "Dockerfile" in the root of the [[Build context|build context]] (which we'll get to later).
- You can also name them whatever you want with .dockerfile appended. Eg "myProject.dockerfile"

