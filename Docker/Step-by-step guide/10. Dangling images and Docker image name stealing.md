This is a bit of a detail but it's an important one to understand.

To understand it, do the following:
1. Run `docker image prune` and then type y + enter when prompted, to clean up a bit
2. Run `docker images` and note what you have in your table, hopefully you shouldn't have any with repository "none" and tag "none"
3. Run `docker build -t thieving:name .` and then `docker images` you should see your new image with name "thieving:name" - note that it should have the same IMAGE ID as your my-first-image. This means it's an identical image, just with a different name.
4. Add a random line of Go like `fmt.Println("hello")` to the main function somewhere, this change to the code will make docker treat this as a different image (different image ID)
5. Run `docker build -t thieving:name .` again
6. Run `docker images` again.

You should now see these 3 images:
![[8. Dangling images and Docker image name stealing.png]]

**What happened here?**
- You just created a "dangling image" - the one with "none:none" as it's name.
- Basically you tried to make a new image with the same name, but a different image ID, as one you already had in your images.
- What happened is your new image *stole* the name from your older "thieving:name" image, leaving the older image with no name, or "dangling"
- Dangling images can still be used to create containers, and you can still reference them by their ID in commands, like `docker image remove 267` (yes you can abbreviate the ID to the first 3 chars)

If you run the build command again now without changing the code, you'll see nothing happened, that's because the image you attempted to create had *both* the same repository, tag, and image ID. Therefore docker says "this is just the exact same image with the same name you already gave it, i'm not going to do anything"

So you can have 2 identical images (image ID) with different names, but you cannot have any 2 images with the exact same name.

**Finally**
Run `docker image prune` to delete all dangling images - any that are currently in use by a container won't be deleted though.

You can force the deletion of images and their containers with -f (--force) arg, to `docker image rm` and similar commands.