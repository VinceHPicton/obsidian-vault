Now we're going to have a look inside the container our image creates, and that's going to mean running it with a command that doesn't immediately exit...


Run `docker run -it my-first-image:latest /bin/sh`
- Don't worry about the -it option, the i just means interactive (so you can use your terminal to type commands into the container), and the t makes the interactive terminal more human-usable, try it with just -i to see the difference.

You've now told the image to execute the command /bin/sh against the container, this started an interactive terminal program which came with our premade base image of golang:alpine.

You have now been dropped into a shell inside the container, run `ls` to see what's in the current directory and you'll see your main.go which you copied in during image creation, and the file called "my-go-binary" which was generated by the 3rd instruction in your dockerfile.

Move up a directory with `cd ..` and run `ls` again. You can now see a whole bunch of directories, which are what came with the golang:alpine base image. 

Have a look in bin (short for binaries) with `cd /bin` and run `ls`. You'll see one of the many files there is called `sh`. This is the binary file which you're running right now.

Play around as much as you want, if you want to reset, you can just spawn a new container with `docker run`. When you're ready to move on, just type `exit` and hit enter, which will kill the "main process", stopping the container and giving you back your normal terminal.

What you're looking at here is a tiny linux-based computer (alpine is short for alpine linux - a lightweight distro), running inside your personal computer, via docker.

I would also encourage you to comment out line 3 and build the image with just the first 2 lines, to see how the image building process has progressed at that point (commenting out to a point and having a look around with /bin/sh to see what's happening is generally a great trick when building or editing a dockerfile).

**Finally**
Run `docker container ls -a` to see all your containers, including *stopped* containers.
`docker container ls` without the -a only shows you containers which are currently running.

What exactly is a *stopped* container?