In the last section, we had to run our container with: `docker run -d empty-http ./my-go-binary`

We had to supply the command to run when starting the container - the command which will kick off the main process, otherwise when starting how would the container know what to do?

Try running it without the command: `docker run -d empty-http` and then list your containers, you'll see that the container you just made stopped immediately.

Because this container wasnt passed a command when it was created, and it's Dockerfile doesn't define a default command, this container is useless, it can never actually run anything, if you tried to restart with `docker start` you'll see it just immediately stops again, and there's no way to change the lack of command. In fact you may aswell delete the container now with `docker container rm ID_OR_NAME`

**Defining a default run command**
This is where ENTRYPOINT and CMD come in. If you've written a Dockerfile for an image, you probably know what command a container from that image should run to get started. 
You may even want to **force** the image to only ever be able to run 1 specific command, because running anything else wouldn't make any sense.

In our image, the only thing you can do (other than things you could do with just the base image of golang:alpine) is run the binary we made, so we're going to force the image to only ever be able to start a container with that command. We'll do this with the ENTRYPOINT instruction.

Add 1 line to your Dockerfile so it looks like: 
```
# Layer 1
FROM golang:alpine

# Layer 2
COPY main.go .

# Layer 3
RUN go build -o my-go-binary main.go

# Layer 4
ENTRYPOINT ["./my-go-binary"]
```

Now create an image from our new Dockerfile with `docker build -t http:entrypoint .`
And run it: `docker run http:entrypoint` (you can kill it with Ctrl+C but read the next point first)

This time we didn't need to add a command, because we already told it what to do in the Dockerfile. Run `docker ps` in another terminal to see it running.

Now try to give it the /bin/sh command: `docker run -it http:empty /bin/sh`

You'll see that although it's taken your terminal, you're not in the shell program (/bin/sh): the normal commands like `ls` won't work. Docker just ignored the command you gave it, because ENTRYPOINT overrides any command the image user passes.

**So what does CMD do?**
The same thing as ENTRYPOINT, it gives the image a default command to run, except if you use CMD, you *can* override the CMD when you run the image with `docker run`. Try it out yourself.


In a sentence:
ENTRYPOINT makes the container into an executable, whereas CMD just provides a default.

